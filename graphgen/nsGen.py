import networkx as nx
__NX_VERSION__ = int(nx.__version__.split('.')[0])
import time, re

''' nsGen.py generates a NS file associated with the given graph file.  
The file generated will "enclaves" with ct, crypto, traffic and server boxes.
'''

class NSGen():
    def __init__(self, g, filename, args):
        self.g = g
        self.filename = filename
        self.args = args

    def writeNS(self, g, filename, args):
        self.g = g
        self.filename = filename
        self.args = args
        self.fh = open(self.filename, "w")
        self.useDPDK = self.args.useDPDK
        
        # Determine number of servers and clients per enclave
        self.numServers = int(args.numServers)
        self.numClients = int(args.numClients)

        # Determine number of External (non Enclave) nodes
        self.numExternal = len(nx.get_node_attributes(g, 'external'))
        self.enclaves = nx.get_node_attributes(g, 'enclaves')
        self.enclaves = list(self.enclaves)
        self.enclaves.sort(key=lambda x: int(re.search('[0-9]+', x).group(0)))
   
        # Determine total enclaves based on number of specified interfaces for the vrouter
        # need to subtract out external nodes
        self.numEnclaves = len(nx.get_node_attributes(g, 'ifs')) - self.numExternal
        self.numTees = len(nx.get_edge_attributes(g, 'tee'))
        self.useCrypto = args.useCrypto
    
        self.writePreamble(args.startCmd)
        lans = self.writeEnclaveNodes(self.args.os, self.args.ct_os)
        self.writeExternalNodes()
        self.writeLansLinks(lans)
        self.writeIPs()
        self.writeTeeNodes(self.args.os)
    
        if args.useContainers:
            self.writeContainers()

        self.writeStartCmds()
        self.writeEpilogue()
        self.fh.close()

    def writePreamble(self, start_cmd):
        ''' This function writes the NS preamble, as well as setting up start command strings'''
        
        tstr = time.asctime(time.gmtime(time.time()))
        self.fh.write("# Autogenerated by nsGen.py - %s UTC\n" % tstr)
        self.fh.write("set ns [new Simulator]\n")
        self.fh.write("source tb_compat.tcl\n")
        self.fh.write("\nset magi_str \"sudo python /proj/edgect/magi/current/magi_bootstrap.py -fp /proj/edgect/magi/current/\"\n")
        if self.useDPDK:
            self.fh.write("\nset click_str \"/proj/edgect/exp_scripts/startClickDPDK.sh %s\"\n" % self.filename.split('.')[0])
        else:
            self.fh.write("\nset click_str \"/proj/edgect/exp_scripts/startClickAny.sh %s\"\n" % self.filename.split('.')[0])

        if self.args.writeRoutes:
            self.fh.write("\nset ct_str \"/proj/edgect/exp_scripts/updateRoutesAny.sh %s\"\n" % self.filename.split('.')[0])
        
        # Always have a basic my_start regardless of user definition
        if start_cmd == "":
            self.fh.write("\nset my_start \"touch /tmp/my_start\"\n")
        else:
            self.fh.write("\nset my_start \"%s\"\n" % start_cmd)

        if not self.args.useContainers:
            self.fh.write("\n# Create hardware types\n")

            if self.useDPDK:
                self.fh.write("tb-make-soft-vtype click_type {sm dl380g3 MicroCloud}\n")
            else:
                self.fh.write("tb-make-soft-vtype click_type {dl380g3 MicroCloud}\n")

            self.fh.write("tb-make-soft-vtype ct_type {sm dl380g3}\n")
            self.fh.write("tb-make-soft-vtype crypto_type {sm dl380g3 MicroCloud}\n")
            self.fh.write("tb-make-soft-vtype cli_server_type {sm dl380g3 MicroCloud}\n")
                      
        
    def writeEnclaveNodes(self, os, ct_os):
        ''' Write the enclave nodes, providing the specified os, number of server 
        and number of clients per enclave '''

        # We build up the LAN string as we go to save time later
        lan_strs = []
        self.fh.write("\n# Enclaves\n")
        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))
            self.fh.write("\n# Enclave %d\n" % enc)
            lstr = ""
        
            # Legacy BLAH.  If number of servers per enclave is 1, don_t add a server number
            lstr = "ct%d" % enc
            if self.numServers == 1:
                lstr = "%s server%d" % (lstr, enc)
                self.fh.write("set server%d [$ns node]\n" % enc)
                self.fh.write("tb-set-hardware $server%d cli_server_type\n" % enc)
                if not self.args.useContainers:
                    self.fh.write("tb-set-node-os $server%d %s\n" % (enc, os))

            else:
                for x in range(self.numServers):
                    lstr = "%s server%d%d" % (lstr, enc, x + 1)
                    self.fh.write("set server%d%d [$ns node]\n" % (enc, x + 1))
                    self.fh.write("tb-set-hardware $server%d%d cli_server_type\n" % (enc, x + 1))
                    if not self.args.useContainers:
                        self.fh.write("tb-set-node-os $server%d%d %s\n" % (enc, x + 1, os))


            # Write Client nodes
            for x in range(self.numClients):
                self.fh.write("set traf%d%d [$ns node]\n" % (enc, x + 1))
                self.fh.write("tb-set-hardware $traf%d%d cli_server_type\n" % (enc, x + 1))
                lstr = "%s traf%d%d" % (lstr, enc, x + 1)
                if not self.args.useContainers:
                    self.fh.write("tb-set-node-os $traf%d%d %s\n" % (enc, x + 1, os))

            # Write CT and Crypto nodes
            self.fh.write("set ct%d [$ns node]\n" % enc)
            self.fh.write("tb-set-node-os $ct%d %s\n" % (enc, ct_os))
            self.fh.write("tb-set-hardware $ct%d ct_type\n" % (enc))

            if __NX_VERSION__ > 1:
                 neighbors = [y for y in self.g.neighbors(enclave)]
            else:
                 neighbors = self.g.neighbors(enclave)
            
            if self.useCrypto:
                c = 1
                for _ in neighbors:
                    if len(neighbors) == 1:
                        self.fh.write("set crypto%d [$ns node]\n" % enc)
                        self.fh.write("tb-set-node-os ${crypto%d} %s\n" % (enc, os))
                        self.fh.write("tb-set-hardware ${crypto%d} crypto_type\n" % (enc))

                    else:
                        self.fh.write("set crypto%d-%d [$ns node]\n" % (enc, c))
                        self.fh.write("tb-set-node-os ${crypto%d-%d} %s\n" % (enc, c, os))
                        self.fh.write("tb-set-hardware ${crypto%d-%d} crypto_type\n" % (enc, c))

                    c = c + 1
            lan_strs.append(lstr)

        # Write the control node and vrouter node
        self.fh.write("\nset vrouter [$ns node]\n")
        if self.useDPDK:
            self.fh.write("tb-set-node-os $vrouter Ubuntu1604-STD\n")
        else:
            self.fh.write("tb-set-node-os $vrouter Ubuntu1204-64-CT-CL2\n")

        self.fh.write("tb-set-hardware $vrouter click_type\n")
        
        self.fh.write("set control [$ns node]\n")
        self.fh.write("tb-set-node-os $control %s\n" % os)
        self.fh.write("tb-set-hardware $control cli_server_type\n")

        return lan_strs

    def writeExternalNodes(self):
        ''' Write any external nodes for this experiment '''
        
        self.fh.write("\n# External Nodes\n")
        for extern_node in range(1, self.numExternal+1):
            self.fh.write("set ext%d [$ns node]\n" % (extern_node))
            self.fh.write("tb-set-node-os $ext%d %s\n" % (extern_node, self.args.os))
            #FIXME: add options for hardware for types (extern, click, etc)
            self.fh.write("tb-set-hardware $ext%d cli_server_type\n" % (extern_node))


    def writeLansLinks(self, lans):
        self.fh.write("\n# Lans\n")
        link_str = ""
        elink_str = ""
        multiplex_str = ""
        
        enclaves = nx.get_node_attributes(self.g, 'enclaves')
        # Write the LANs for each enclave, as well as the ct-crypto link and crpyto-vrouter links
        for lan, lan_count in zip(lans, range(1, len(lans)+1)):
            # FIXME: lincoln, need type and format checks on inputs, requires formatting with Gbps Mbps, 0ms, etc
            self.fh.write(
                "set lan{0} [$ns make-lan \"{1}\" {2} {3}]\n".format(
                    lan_count, lan, self.args.bw[:-2], self.args.delay,
                )
            )
            enclave = enclaves["e{}".format(lan_count)]
            if self.useCrypto:
                for neighbors, num_neighbor in zip(self.g.neighbors(enclave), range(len(self.g.neighbors(enclave)))):
                    if len(self.g.neighbors(enclave)) == 1: 
                        link_str = "{0}set link{1} [$ns duplex-link $ct{1} $crypto{1} {2} {3} DropTail]\n".format(
                            link_str, lan_count, self.args.bw[:-2], self.args.delay,
                        )
                        elink_str = "{0}set elink{1} [$ns duplex-link $crypto{1} $vrouter {2} {3} DropTail]\n".format(
                            link_str, lan_count, self.args.bw[:-2], self.args.delay,
                        )
                        multiplex_str = "{0}tb-set-multiplexed $elink{1} 1\ntb-set-noshaping $elink{1} 1\n".format(
                            multiplex_str, lan_count,
                        )
                    else:
                        link_str = "{0}set link{1}-{2} [$ns duplex-link $ct{1} $\{crypto{1}-{2}\} {3} {4} DropTail]\n".format(
                            link_str, lan_count, num_neighbor, self.args.bw[:-2], self.args.delay,
                        )
                        elink_str = "{0}set elink{1}-{2} [$ns duplex-link $\{crypto{1}-{2}\} $vrouter {3} {4} DropTail]\n".format(
                            elink_str, lan_count, num_neighbor, self.args.bw[:-2], self.args.delay,
                        )
                        multiplex_str = "{0}tb-set-multiplexed $\{elink{1}-{2}\} 1\ntb-set-noshaping $\{elink{1}-{2}\} 1\n".format(
                            multiplex_str, lan_count, num_neighbor,
                        )
            else:
                for neighbors, num_neighbor in zip(self.g.neighbors(enclave), range(len(self.g.neighbors(enclave)))):
                    if len(self.g.neighbors(enclave)) == 1: 
                        elink_str = "{0}set elink{1} [$ns duplex-link $ct{1} $vrouter {2} {3} DropTail]\n".format(
                            elink_str, lan_count, self.args.bw[:-2], self.args.delay,
                        )
                        multiplex_str = "{0}tb-set-multiplexed $elink{1} 1\ntb-set-noshaping $elink{1} 1\n".format(
                            multiplex_str, lan_count,
                        )
                    else:
                        elink_str = "{0}set elink{1}-{2} [$ns duplex-link $ct{1} $vrouter {2} {3} DropTail]\n".format(
                            elink_str, lan_count, num_neighbor,
                        )
                        multiplex_str = "{0}tb-set-multiplexed $\{elink{1}-{2}\} 1\ntb-set-noshaping $\{elink{1}-{2}\} 1\n".format(
                            multiplex_str, lan_count, num_neighbor,
                        )

        # I (ek) try to bunch everything in the output file together for easy reading.  Thats why all the link_strs
        # and elink_strs are grouped together
        self.fh.write("\n# Internal Links\n")
        self.fh.write(link_str)
        self.fh.write("\n# Egress Links\n")
        self.fh.write(elink_str)

        self.fh.write("\ntb-set-vlink-emulation \"vlan\"\n")
        self.fh.write(multiplex_str)
        
        # Write External Links
        self.fh.write("\n# External Node Links\n")
        for extern_nodes in range(1, self.numExternal+1):
            self.fh.write(
                "set olink{0} [$ns duplex-link $vrouter $ext{0} {1} {2} DropTail]\n".format(
                    extern_nodes, self.args.bw[:-2], self.args.delay,
                )
            )
            self.fh.write(
                "tb-set-multiplexed $olink{0} 1\ntb-set-noshaping $olink{0}\n".format(
                    extern_nodes,
                )
            )

    def writeIPs(self):
        self.fh.write("\n# IPS\n")

        # Enumerate and write the Enclave IPs.  Enclaves are given /16's.  Thus enclave 1 is
        # 10.1.0.0/16 etc...  10.100 is reserved for internal use.  If we ever have more than 99
        # enclaves, we'll have to deal.

        ifs = nx.get_node_attributes(self.g, 'ifs')
        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))
            addr = 1
            self.fh.write("\n# IPs for Enclave %d\n" % enc)
            for x in range(self.numClients):
                self.fh.write("tb-set-ip-lan $traf%d%d $lan%d 10.%d.1.%d\n"
                     % (enc, x + 1, enc, enc, addr))
                addr = addr + 1
            if self.numServers == 1:
                self.fh.write("tb-set-ip-lan $server%d $lan%d 10.%d.1.%d\n"
                              % (enc, enc, enc, addr))
            else:
                for x in range(self.numServers):
                    self.fh.write("tb-set-ip-lan $server%d%d $lan%d 10.%d.1.%d\n"
                                  % (enc, (x + 1), enc, enc, addr))
                    addr = addr + 1


            self.fh.write("tb-set-ip-lan $ct%d $lan%d 10.%d.1.100\n"
                          % (enc, enc, enc))

            if __NX_VERSION__ > 1:
                 neighbors = [y for y in self.g.neighbors(enclave)]
            else:
                 neighbors = self.g.neighbors(enclave)

            if self.useCrypto:
                x = 1
                for _ in neighbors:
                    if len(neighbors) == 1:
                        self.fh.write("tb-set-ip-link $ct%d $link%d 10.%d.2.1\n"
                                      % (enc, enc, enc))
                        self.fh.write("tb-set-ip-link $crypto%d $link%d 10.%d.2.2\n"
                                      % (enc, enc, enc))
                    else:
                        c_enc = int(re.search("[0-9]+", ifs[enclave][x - 1]).group(0))
                        self.fh.write("tb-set-ip-link $ct%d ${link%d-%d} 10.%d.2.1\n"
                                      % (enc, enc, x, c_enc))
                        self.fh.write("tb-set-ip-link ${crypto%d-%d} ${link%d-%d} 10.%d.2.2\n"
                                      % (enc, x, enc, x, c_enc))

                    x = x + 1

        self.fh.write("\n# Egress link IPS\n")
        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))       
            x = 1

            if __NX_VERSION__ > 1:
                 neighbors = [y for y in self.g.neighbors(enclave)]
            else:
                 neighbors = self.g.neighbors(enclave)

            for _ in neighbors:
                if len(neighbors) == 1:
                    if self.useCrypto:
                        self.fh.write("tb-set-ip-link $crypto%d $elink%d 10.%d.10.1\n"
                                      % (enc, enc, enc))
                        self.fh.write("tb-set-ip-link $vrouter $elink%d 10.%d.10.2\n"
                                      % (enc, enc))
                    else:
                        self.fh.write("tb-set-ip-link $ct%d $elink%d 10.%d.2.1\n"
                                      % (enc, enc, enc))
                        self.fh.write("tb-set-ip-link $vrouter $elink%d 10.%d.2.2\n"
                                      % (enc, enc))
                else:
                    c_enc = int(re.search("[0-9]+", ifs[enclave][x - 1]).group(0))
                    if self.useCrypto:
                        self.fh.write("tb-set-ip-link ${crypto%d-%d} ${elink%d-%d} 10.%d.10.1\n"
                                      % (enc, x, enc, x, c_enc))
                        self.fh.write("tb-set-ip-link $vrouter ${elink%d-%d} 10.%d.10.2\n"
                                      % (enc, x, c_enc))
                    else:
                        self.fh.write("tb-set-ip-link $ct%d ${elink%d-%d} 10.%d.2.1\n"
                                      % (enc, enc, x, c_enc))
                        self.fh.write("tb-set-ip-link $vrouter ${elink%d-%d} 10.%d.2.2\n"
                                      % (enc, x, c_enc))

                x = x + 1

        # External Links are using the 10.100.X\24s.  We use the 10.100.150\24 for
        # internal vrouter routing.  If we ever have more than 149 external nodes, we'll
        # have to deal.
    
        self.fh.write("\n# External Node Link IPS \n")
        for x in range(self.numExternal):
            self.fh.write("tb-set-ip-link $ext%d $olink%d 10.100.%d.1\n" % (x + 1, x + 1, x + 1))
            self.fh.write("tb-set-ip-link $vrouter $olink%d 10.100.%d.2\n" % (x + 1, x + 1))

    def writeContainers(self):
        self.fh.write("\n# Container Partitioning\n")

        # All clients and servers in an enclave are placed in the same partition
        # Make this an option?
 
        count = 0

        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))
            for x in range(self.numClients):
                self.fh.write("tb-add-node-attribute $traf%d%d containers:partition %d\n"
                              % (enc, x + 1, enc))
            if self.numServers == 1:
                self.fh.write("tb-add-node-attribute $server%d containers:partition %d\n"
                              % (enc, enc))
            else:
                for x in range(self.numServers):
                    self.fh.write("tb-add-node-attribute $server%d%d containers:partition %d\n"
                                  % (enc, x + 1, enc))
            count = count + 1

        count = count + 1
        # Everything is its own partition/embedded pnode.  Is this right way to do this?
        # More options?
    
        self.fh.write("\n")
        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))
            self.fh.write("tb-add-node-attribute $ct%d containers:partition %d\n"
                          % (enc, count))
            count = count + 1

            if __NX_VERSION__ > 1:
                 neighbors = [y for y in self.g.neighbors(enclave)]
            else:
                 neighbors = self.g.neighbors(enclave)

            if self.useCrypto:
                if len(neighbors) == 1:
                    self.fh.write("tb-add-node-attribute $crypto%d containers:partition %d\n"
                                      % (enc, count))
                    count = count + 1
                else:
                    x = 1
                    for _ in neighbors:
                        self.fh.write("tb-add-node-attribute ${crypto%d-%d} containers:partition %d\n"
                                      % (enc, x, count))
                        count = count + 1
                        x = x + 1

        for n in range(self.numExternal):
            self.fh.write("tb-add-node-attribute $ext%d containers:partition %d\n"
                          % (n + 1, count))
            count = count + 1

        for n in range(self.numTees):
            self.fh.write("tb-add-node-attribute $tee%d containers:partition %d\n"
                          % (n + 1, count))
            count = count + 1
        
        
        self.fh.write("\n")
        self.fh.write("tb-add-node-attribute $vrouter containers:partition %d\n"
                      % (count))
        count = count + 1
        self.fh.write("tb-add-node-attribute $control containers:partition %d\n"
                      % (count))

        self.fh.write("\n# Embed Physical Nodes\n")
        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))
            self.fh.write("tb-add-node-attribute $ct%d containers:node_type embedded_pnode\n" % (enc))

            if __NX_VERSION__ > 1:
                 neighbors = [y for y in self.g.neighbors(enclave)]
            else:
                 neighbors = self.g.neighbors(enclave)

            if self.useCrypto:
                if len(neighbors) == 1:
                    self.fh.write("tb-add-node-attribute $crypto%d containers:node_type embedded_pnode\n" % (enc))
                else:
                    x = 1
                    for _ in neighbors:
                        self.fh.write("tb-add-node-attribute ${crypto%d-%d} containers:node_type embedded_pnode\n" % (enc, x))
                        x = x + 1


        # External nodes could possibly be containerized.  Have to consider this!
        
        for n in range(self.numExternal):
            self.fh.write("tb-add-node-attribute $ext%d containers:node_type embedded_pnode\n" % (n + 1))
            
        for n in range(self.numTees):
            self.fh.write("tb-add-node-attribute $tee%d containers:node_type embedded_pnode\n" % (n + 1))
        
        self.fh.write("\ntb-add-node-attribute $vrouter containers:node_type embedded_pnode\n")
        self.fh.write("tb-add-node-attribute $control containers:node_type embedded_pnode\n")

    def writeStartCmds(self):
        self.fh.write("\n# Start Commands\n")
        for enclave in self.enclaves:
            enc = int(re.search("[0-9]+", enclave).group(0))  
            self.fh.write("\n")
            for x in range(self.numClients):
                self.fh.write("tb-set-node-startcmd $traf%d%d \"$my_start; $magi_str\"\n" %
                              (enc, x + 1))
            if self.numServers == 1:
                self.fh.write("tb-set-node-startcmd $server%d \"$my_start; $magi_str\"\n"
                              % (enc))
            else:
                for x in range(self.numServers):
                    self.fh.write("tb-set-node-startcmd $server%d%d \"$my_start; $magi_str\"\n"
                                  % (enc, x + 1))

            if self.args.writeRoutes:
                self.fh.write("tb-set-node-startcmd $ct%d \"$my_start; $ct_str; $magi_str\"\n"
                              % (enc))
        
            else:
                self.fh.write("tb-set-node-startcmd $ct%d \"$my_start; $magi_str\"\n"
                              % (enc))
        
            if __NX_VERSION__ > 1:
                 neighbors = [y for y in self.g.neighbors(enclave)]
            else:
                 neighbors = self.g.neighbors(enclave)

            if self.useCrypto:
                if len(neighbors) == 1:
                    self.fh.write("tb-set-node-startcmd $crypto%d \"$my_start; $magi_str\"\n"
                                  % (enc))
                else:
                    x = 1
                    for _ in neighbors:
                        self.fh.write("tb-set-node-startcmd ${crypto%d-%d} \"$my_start; $magi_str\"\n"
                                      % (enc, x))
                        x = x + 1
                    
        for n in range(self.numExternal):
            self.fh.write("tb-set-node-startcmd $ext%d \"$my_start; $magi_str\"\n"
                          % (n + 1))
        
        self.fh.write("\ntb-set-node-startcmd $vrouter \"$click_str; $my_start; $magi_str\"\n")
        self.fh.write("tb-set-node-startcmd $control \"sudo python /proj/edgect/exp_scripts/fixHosts.py; $my_start; $magi_str\"\n")

    def writeTeeNodes(self, os):
        self.fh.write("\n# Write Tee Nodes\n")
        tees = nx.get_edge_attributes(self.g, 'tee')
        c = 1
        x = 151
        for edge in tees:
            self.fh.write("set tee%d [$ns node]\n" % c)
            self.fh.write("tb-set-node-os $tee%d %s\n" % (c, os))
            self.fh.write("tb-set-node-startcmd $tee%d \"$my_start; $magi_str\"\n" % c)
            self.fh.write("tb-set-hardware $tee%d cli_server_type\n" % c)
            self.fh.write("set tlink%d [$ns duplex-link $vrouter $tee%d 1000Mb 0.0ms DropTail]\n" % (c, c))
            self.fh.write("tb-set-ip-link $tee%d $tlink%d 10.100.%d.1\n" % (c, c,  x))
            self.fh.write("tb-set-ip-link $vrouter $tlink%d 10.100.%d.2\n" % (c,  x))
            self.fh.write("tb-set-multiplexed $tlink%d 1\ntb-set-noshaping $tlink%d\n" % (c, c))

            c = c + 1
            x = x + 1
    
    def writeEpilogue(self):
        self.fh.write("\n# Epilogue\n")
        self.fh.write("$ns rtproto Static\n")
        self.fh.write("$ns run\n")
