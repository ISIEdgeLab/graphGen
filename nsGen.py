import networkx as nx
import time

''' nsGen.py generates a NS file associated with the given graph file.  
The file generated will "enclaves" with ct, crypto, traffic and server boxes.
'''

def writeNS(g, filename, args):
    fh = open(filename, "w")

    # Determine number of servers and clients per enclave
    numServers = int(args.numServers)
    numClients = int(args.numClients)

    # Determine number of External (non Enclave) nodes
    numExternal = len(nx.get_node_attributes(g, 'external'))

    # Determine total enclaves based on number of specified interfaces for the vrouter
    # need to subtract out external nodes
    numEnclaves = len(nx.get_node_attributes(g, 'ifs')) - numExternal
    numTees = len(nx.get_edge_attributes(g, 'tee'))

    writePreamble(fh, filename, args.startCmd)
    lans = writeEnclaveNodes(numEnclaves, "Ubuntu1404-64-STD", numServers, numClients, fh)
    writeExternalNodes(numExternal, "Ubuntu1404-64-STD", fh)
    writeLansLinks(lans, numExternal, fh)
    writeIPs(numEnclaves, numExternal, numServers, numClients, fh)
    writeTeeNodes(g, "Ubuntu1404-64-STD", fh)
    
    if args.useContainers:
        writeContainers(numEnclaves, numExternal, numServers, numClients, numTees, fh)

    writeStartCmds(numEnclaves, numExternal, numServers, numClients, fh)
    writeEpilogue(fh)
    fh.close()

def writePreamble(fh, filename, start_cmd):
    ''' This function writes the NS preamble, as well as setting up start command strings'''
    
    tstr = time.asctime(time.gmtime(time.time()))
    fh.write("# Autogenerated by nsGen.py - %s UTC\n" % tstr)
    fh.write("set ns [new Simulator]\n")
    fh.write("source tb_compat.tcl\n")
    fh.write("\nset magi_str \"sudo python /proj/edgect/magi/current/magi_bootstrap.py -fp /proj/edgect/magi/current/\"\n")
    fh.write("\nset click_str \"/proj/edgect/exp_scripts/startClickAny.sh %s\"\n" % filename.split('.')[0])

    # Always have a basic my_start regardless of user definition
    if start_cmd == "":
        fh.write("\nset my_start \"touch /tmp/my_start\"\n")
    else:
        fh.write("\nset my_start \"%s\"\n" % start_cmd)
        
def writeEnclaveNodes(numEnclaves, os, numServers, numClients, fh):
    ''' Write the enclave nodes, providing the specified os, number of server 
    and number of clients per enclave '''

    # We build up the LAN string as we go to save time later
    lan_strs = []
    fh.write("\n# Enclaves\n")
    for n in range(numEnclaves):
        enc = n + 1
        fh.write("\n# Enclave %d\n" % enc)
        lstr = ""
        
        # Legacy BLAH.  If number of servers per enclave is 1, don_t add a server number
        if numServers == 1:
            lstr = "server%d ct%d" % (enc, enc)
            fh.write("set server%d [$ns node]\n" % enc)
        else:
            for x in range(numServers):
                if x == 0:
                    lstr = "server%d%d ct%d" % (enc, x + 1, enc)
                else:
                    lstr = "%s server%d%d ct%d" % (lstr, enc, x + 1, enc)
                fh.write("set server%d%d [$ns node]\n" % (enc, x + 1))

        # Write Client nodes
        for x in range(numClients):
            fh.write("set traf%d%d [$ns node]\n" % (enc, x + 1))
            lstr = "%s traf%d%d" % (lstr, enc, x + 1)

        # Write CT and Crypto nodes
        fh.write("set ct%d [$ns node]\n" % enc)
        fh.write("tb-set-node-os $ct%d %s\n" % (enc, os))
        
        fh.write("set crypto%d [$ns node]\n" % enc)
        fh.write("tb-set-node-os $crypto%d %s\n" % (enc, os))
        lan_strs.append(lstr)

    # Write the control node and vrouter node
    fh.write("\nset vrouter [$ns node]\n")
    fh.write("tb-set-node-os $vrouter Ubuntu1204-64-CT-CL2\n")
    fh.write("set control [$ns node]\n")
    fh.write("tb-set-node-os $control %s\n" % os)
    return lan_strs

def writeExternalNodes(numExternal, os, fh):
    ''' Write any external nodes for this experiment '''
    
    fh.write("\n# External Nodes\n")
    for x in range(numExternal):
        fh.write("set ext%d [$ns node]\n" % (x + 1))
        fh.write("tb-set-node-os ext%d %s\n" % (x + 1, os))

def writeLansLinks(lans, numExternal, fh):
    c = 1
    fh.write("\n# Lans\n")
    link_str = ""
    elink_str = ""

    # Write the LANs for each enclave, as well as the ct-crypto link and crpyto-vrouter links
    for lan in lans:
        fh.write("set lan%d [$ns make-lan \"%s\" 1000Mb 0ms]\n" % (c, lan))
        link_str = "%sset link%d [$ns duplex-link $ct%d $crypto%d 1000Mb 0.0ms DropTail]\n" % (link_str, c, c, c)
        elink_str = "%sset elink%d [$ns duplex-link $crypto%d $vrouter 1000Mb 0.0ms DropTail]\n" % (elink_str, c, c)
        c = c + 1

    # I (ek) try to bunch everything in the output file together for easy reading.  Thats why all the link_strs
    # and elink_strs are grouped together
    fh.write("\n# Internal Links\n")
    fh.write(link_str)
    fh.write("\n# Egress Links\n")
    fh.write(elink_str)

    # Write External Links
    fh.write("\n# External Node Links\n")
    for x in range(numExternal):
        fh.write("set olink%d [$ns duplex-link $vrouter $ext%d 1000Mb 0.0ms DropTail]\n" % (x + 1, x + 1))

def writeIPs(numEnclaves, numExternal, numServers, numClients, fh):
    fh.write("\n# IPS\n")

    # Enumerate and write the Enclave IPs.  Enclaves are given /16's.  Thus enclave 1 is
    # 10.1.0.0/16 etc...  10.100 is reserved for internal use.  If we ever have more than 99
    # enclaves, we'll have to deal.

    
    for n in range(numEnclaves):
        enc = n + 1
        addr = 1
        fh.write("\n# IPs for Enclave %d\n" % enc)
        for x in range(numClients):
            fh.write("tb-set-ip-lan $traf%d%d $lan%d 10.%d.1.%d\n"
                     % (enc, x + 1, enc, enc, addr))
            addr = addr + 1
        if numServers == 1:
            fh.write("tb-set-ip-lan $server%d $lan%d 10.%d.1.%d\n"
                     % (enc, enc, enc, addr))
        else:
            for x in range(numServers):
                fh.write("tb-set-ip-lan $server%d%d $lan%d 10.%d.1.%d\n"
                         % (enc, (x + 1), enc, enc, addr))
                addr = addr + 1


        fh.write("tb-set-ip-lan $ct%d $lan%d 10.%d.1.100\n"
                 % (enc, enc, enc))
        fh.write("tb-set-ip-link $ct%d $link%d 10.%d.2.1\n"
                 % (enc, enc, enc))
        fh.write("tb-set-ip-link $crypto%d $link%d 10.%d.2.2\n"
                 % (enc, enc, enc))

    fh.write("\n# Egress link IPS\n")
    for n in range(numEnclaves):
        enc = n + 1
        fh.write("tb-set-ip-link $crypto%d $elink%d 10.%d.10.1\n"
                 % (enc, enc, enc))
        fh.write("tb-set-ip-link $vrouter $elink%d 10.%d.10.2\n"
                 % (enc, enc))

    # External Links are using the 10.100.X\24s.  We use the 10.100.150\24 for
    # internal vrouter routing.  If we ever have more than 149 external nodes, we'll
    # have to deal.
    
    fh.write("\n# External Node Link IPS \n")
    for x in range(numExternal):
        fh.write("tb-set-ip-link $ext%d $olink%d 10.100.%d.1\n" % (x + 1, x + 1, x + 1))
        fh.write("tb-set-ip-link $vrouter $olink%d 10.100.%d.2\n" % (x + 1, x + 1))

def writeContainers(numEnclaves, numExternal, numServers, numClients, numTees, fh):
    fh.write("\n# Container Partitioning\n")

    # All clients and servers in an enclave are placed in the same partition
    # Make this an option?
 
    count = 0

    for n in range(numEnclaves):
        enc = n + 1
        for x in range(numClients):
            fh.write("tb-add-node-attribute $traf%d%d containers:partition %d\n"
                     % (enc, x + 1, n))
        if numServers == 1:
            fh.write("tb-add-node-attribute $server%d containers:partition %d\n"
                 % (enc, n))
        else:
            for x in range(numServers):
                fh.write("tb-add-node-attribute $server%d%d containers:partition %d\n"
                         % (enc, x + 1, n))
        count = n
    count = count + 1

    # Everything is its own partition/embedded pnode.  Is this right way to do this?
    # More options?
    
    fh.write("\n")
    for n in range(numEnclaves):
        enc = n + 1
        
        fh.write("tb-add-node-attribute $ct%d containers:partition %d\n"
                 % (enc, count))
        count = count + 1
        
        fh.write("tb-add-node-attribute $crypto%d containers:partition %d\n"
                 % (enc, count))
        count = count + 1

    for n in range(numExternal):
        fh.write("tb-add-node-attribute $ext%d containers:partition %d\n"
                 % (n + 1, count))
        count = count + 1

    for n in range(numTees):
        fh.write("tb-add-node-attribute $tee%d containers:partition %d\n"
                 % (n + 1, count))
        count = count + 1
        
        
    fh.write("\n")
    fh.write("tb-add-node-attribute $vrouter containers:partition %d\n"
             % (count))
    count = count + 1
    fh.write("tb-add-node-attribute $control containers:partition %d\n"
             % (count))

    fh.write("\n# Embed Physical Nodes\n")
    for n in range(numEnclaves):
        fh.write("tb-add-node-attribute $ct%d containers:node_type embedded_pnode\n" % (n + 1))
        fh.write("tb-add-node-attribute $crypto%d containers:node_type embedded_pnode\n" % (n + 1))


    # External nodes could possibly be containerized.  Have to consider this!
    
    for n in range(numExternal):
        fh.write("tb-add-node-attribute $ext%d containers:node_type embedded_pnode\n" % (n + 1))

    for n in range(numTees):
        fh.write("tb-add-node-attribute $tee%d containers:node_type embedded_pnode\n" % (n + 1))
        
    fh.write("\ntb-add-node-attribute $vrouter containers:node_type embedded_pnode\n")
    fh.write("tb-add-node-attribute $control containers:node_type embedded_pnode\n")

def writeStartCmds(numEnclaves, numExternal, numServers, numClients, fh):
    fh.write("\n# Start Commands\n")
    for n in range(numEnclaves):
        enc = n + 1
        fh.write("\n")
        for x in range(numClients):
            fh.write("tb-set-node-startcmd $traf%d%d \"$my_start; $magi_str\"\n" %
                     (enc, x + 1))
        if numServers == 1:
            fh.write("tb-set-node-startcmd $server%d \"$my_start; $magi_str\"\n"
                     % (enc))
        else:
            for x in range(numServers):
                fh.write("tb-set-node-startcmd $server%d%d \"$my_start; $magi_str\"\n"
                         % (enc, x + 1))
        fh.write("tb-set-node-startcmd $ct%d \"$my_start; $magi_str\"\n"
                 % (enc))
        fh.write("tb-set-node-startcmd $crypto%d \"$my_start; $magi_str\"\n"
                 % (enc))
                
    for n in range(numExternal):
        fh.write("tb-set-node-startcmd $ext%d \"$my_start; $magi_str\"\n"
                % (n + 1))
        
    fh.write("\ntb-set-node-startcmd $vrouter \"$click_str; $my_start; $magi_str\"\n")
    fh.write("tb-set-node-startcmd $control \"sudo python /proj/edgect/exp_scripts/fixHosts.py; $my_start; $magi_str\"\n")

def writeTeeNodes(g, os, fh):
    fh.write("\n# Write Tee Nodes\n")
    tees = nx.get_edge_attributes(g, 'tee')
    c = 1
    x = 151
    for edge in tees:
        fh.write("set tee%d [$ns node]\n" % c)
        fh.write("tb-set-node-os $tee%d %s\n" % (c, os))
        fh.write("tb-set-node-startcmd $tee%d \"$my_start; $magi_str\"\n" % c)
        fh.write("set tlink%d [$ns duplex-link $vrouter $tee%d 1000Mb 0.0ms DropTail]\n" % (c, c))
        fh.write("tb-set-ip-link $tee%d $tlink%d 10.100.%d.1\n" % (c, c,  x))
        fh.write("tb-set-ip-link $vrouter $tlink%d 10.100.%d.2\n" % (c,  x))
        c = c + 1
        x = x + 1
    
def writeEpilogue(fh):
    fh.write("\n# Epilogue\n")
    fh.write("$ns rtproto Static\n")
    fh.write("$ns run\n")
